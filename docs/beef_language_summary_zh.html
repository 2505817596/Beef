<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#f6f1e7" />
  <title>Beef 语言语法与特性全景（基于仓库源码）</title>
  <style>
    :root {
      --bg: #f6f1e7;
      --paper: #fffaf2;
      --ink: #1c1c1a;
      --muted: #5f5b52;
      --accent: #1f6f8b;
      --accent-2: #d97706;
      --accent-3: #0f766e;
      --line: #e6dccf;
      --shadow: rgba(23, 24, 26, 0.10);
      --code-bg: #0f1413;
      --code-ink: #e8f0ea;
      --code-muted: #8aa39b;
    }

    * { box-sizing: border-box; }

    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Futura", "Trebuchet MS", "Gill Sans", sans-serif;
      color: var(--ink);
      background: radial-gradient(1200px 800px at 8% -10%, #fff0d6 0%, transparent 55%),
                  radial-gradient(1200px 800px at 110% 10%, #d7eef2 0%, transparent 50%),
                  var(--bg);
      line-height: 1.6;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: auto;
      width: 420px;
      height: 420px;
      border-radius: 50%;
      filter: blur(40px);
      opacity: 0.45;
      z-index: -1;
    }

    body::before {
      left: -120px;
      top: 15vh;
      background: radial-gradient(circle at 30% 30%, rgba(217, 119, 6, 0.55), transparent 70%);
    }

    body::after {
      right: -160px;
      bottom: 10vh;
      background: radial-gradient(circle at 30% 30%, rgba(15, 118, 110, 0.5), transparent 70%);
    }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .hero {
      padding: 48px 8vw 32px;
      border-bottom: 1px solid var(--line);
      animation: floatIn 0.8s ease both;
    }

    .hero h1 {
      font-family: "Iowan Old Style", "Palatino Linotype", "Book Antiqua", serif;
      font-size: clamp(28px, 3.4vw, 46px);
      margin: 0 0 12px;
      letter-spacing: 0.5px;
    }

    .hero p {
      max-width: 920px;
      margin: 0;
      color: var(--muted);
      font-size: 1.05rem;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(230px, 0.9fr) minmax(0, 2.4fr);
      gap: 32px;
      padding: 32px 8vw 80px;
    }

    .toc {
      position: sticky;
      top: 24px;
      align-self: start;
      background: var(--paper);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 18px 16px;
      box-shadow: 0 14px 30px var(--shadow);
    }

    .toc h2 {
      font-family: "Iowan Old Style", "Palatino Linotype", "Book Antiqua", serif;
      font-size: 1.1rem;
      margin: 0 0 12px;
    }

    .toc ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 8px;
    }

    .toc a {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .toc a:hover { color: var(--accent); }

    .content {
      display: grid;
      gap: 24px;
    }

    section {
      background: var(--paper);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 20px 20px 18px;
      box-shadow: 0 18px 36px var(--shadow);
      animation: fadeUp 0.65s ease both;
      animation-delay: var(--delay, 0s);
      scroll-margin-top: 24px;
    }

    section h2 {
      margin: 0 0 8px;
      font-family: "Iowan Old Style", "Palatino Linotype", "Book Antiqua", serif;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .tag {
      font-size: 0.72rem;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(31, 111, 139, 0.12);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    section p {
      margin: 0 0 12px;
      color: var(--muted);
    }

    pre {
      margin: 0;
      background: var(--code-bg);
      color: var(--code-ink);
      padding: 14px 16px;
      border-radius: 14px;
      overflow: auto;
      font-family: "Cascadia Code", "JetBrains Mono", "Consolas", "Courier New", monospace;
      font-size: 0.92rem;
      line-height: 1.55;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    code { color: inherit; }

    .note {
      background: linear-gradient(120deg, rgba(31, 111, 139, 0.12), rgba(217, 119, 6, 0.12));
      border-radius: 12px;
      padding: 12px 14px;
      border: 1px dashed rgba(31, 111, 139, 0.3);
      font-size: 0.95rem;
      color: var(--muted);
    }

    .keyword-group {
      margin-top: 16px;
    }

    .keyword-group h3 {
      margin: 0 0 12px;
      font-size: 1.05rem;
      color: var(--accent-3);
      letter-spacing: 0.3px;
    }

    .syntax-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }

    .syntax-card {
      background: #ffffff;
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: 0 10px 24px rgba(23, 24, 26, 0.08);
    }

    .syntax-card h4 {
      margin: 0 0 6px;
      font-size: 1rem;
      color: var(--accent-2);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .syntax-card p {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .syntax-card pre {
      font-size: 0.86rem;
    }

    .syntax-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.94rem;
    }

    .syntax-table th,
    .syntax-table td {
      border: 1px solid var(--line);
      padding: 8px 10px;
      vertical-align: top;
    }

    .syntax-table th {
      background: #f0e4d2;
      text-align: left;
    }

    .syntax-table code {
      font-family: "Cascadia Code", "JetBrains Mono", "Consolas", "Courier New", monospace;
      font-size: 0.9rem;
    }

    footer {
      padding: 24px 8vw 48px;
      color: var(--muted);
      font-size: 0.92rem;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes floatIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 980px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .toc { position: static; }
    }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }
  </style>
</head>
<body>
  <header class="hero">
    <h1>Beef 语言语法与特性全景</h1>
    <p>基于仓库源码（<code>BeefLibs/corlib</code>、<code>IDEHelper/Tests</code>、<code>IDE/Tests</code> 等）整理：覆盖全部关键字、运算符与核心语法结构。每个语法与特性均附示例（以源码上下文为主，个别语法提供“语法形式”示例）。</p>
  </header>

  <main class="layout">
    <aside class="toc">
      <h2>目录</h2>
      <ul>
        <li><a href="#lexical">词法与字面量</a></li>
        <li><a href="#keywords">关键字全量</a></li>
        <li><a href="#operators">运算符与符号全量</a></li>
        <li><a href="#attributes">内建特性（Attributes）</a></li>
        <li><a href="#features">结构化语法特性</a></li>
        <li><a href="#note">说明与参考</a></li>
      </ul>
    </aside>

    <div class="content">
      <section id="lexical" style="--delay: 0.05s;">
        <h2>词法与字面量 <span class="tag">lexical</span></h2>
        <p>标识符、注释、字面量与基本文本形式。</p>
        <div class="syntax-grid">
          <div class="syntax-card">
            <h4><code>标识符 / @转义</code></h4>
            <p>关键字可用 <code>@</code> 作为前缀转义。</p>
            <pre><code class="language-bf">public static void AddTo(this ref StructA @this)
{
    @this.mA += 1000;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>注释</code></h4>
            <p>支持单行与多行注释。</p>
            <pre><code class="language-bf">// single-line comment
/* multi-line
   comment */
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>整数/进制字面量</code></h4>
            <p>支持二/八/十六进制与数字分隔符。</p>
            <pre><code class="language-bf">Test.Assert(0b0111010110111100110100010101 == 123456789);
Test.Assert(0o726746425 == 123456789);
uint64 val = 0x11223344'55667788;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>字符串字面量</code></h4>
            <p>普通、原始与插值字符串。</p>
            <pre><code class="language-bf">var str0 = scope $@"AB\C";
var str1 = scope @$"\A{100+200}B{100+200:X}";
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>数组/字符数组字面量</code></h4>
            <p>数组字面量与字符数组常量。</p>
            <pre><code class="language-bf">int[3] arr2 = .(1, 2, 3);
char8[?] arr0 = "Abcd";
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>特性标注</code></h4>
            <p>中括号语法附加特性。</p>
            <pre><code class="language-bf">[AttributeUsage(.Method)]
struct LogAttribute : Attribute, IComptimeMethodApply
{
}
</code></pre>
          </div>
        </div>
      </section>

      <section id="keywords" style="--delay: 0.08s;">
        <h2>关键字全量 <span class="tag">keywords</span></h2>
        <p>以下按功能分组列出 Beef 关键字及示例。</p>

        <div class="keyword-group">
          <h3>模块与类型声明</h3>
          <div class="syntax-grid">
            <div class="syntax-card">
              <h4><code>namespace</code></h4>
              <p>定义命名空间。</p>
              <pre><code class="language-bf">namespace Tests
{
    class UsingStatic { }
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>using</code></h4>
              <p>导入命名空间或静态成员。</p>
              <pre><code class="language-bf">using System;
using static Tests.USOuter;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>class</code></h4>
              <p>引用类型声明。</p>
              <pre><code class="language-bf">class ClassA
{
    public int mA = 123;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>struct</code></h4>
              <p>值类型声明。</p>
              <pre><code class="language-bf">struct StructA
{
    public int32 mA;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>enum</code></h4>
              <p>枚举与载荷枚举。</p>
              <pre><code class="language-bf">enum EnumE
{
    case A;
    case B(int a);
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>interface</code></h4>
              <p>接口与默认实现。</p>
              <pre><code class="language-bf">interface IFaceA
{
    int FuncA(int a) mut;
    int FuncA2() mut { return 0; }
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>extension</code></h4>
              <p>扩展类型成员。</p>
              <pre><code class="language-bf">extension List<T> where T : IGetExVal
{
    public int GetExVals() { return 0; }
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>typealias</code></h4>
              <p>类型别名。</p>
              <pre><code class="language-bf">typealias AliasA5 = (int, T);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>delegate</code></h4>
              <p>委托类型。</p>
              <pre><code class="language-bf">delegate int(int a) dlg;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>function</code></h4>
              <p>函数指针类型。</p>
              <pre><code class="language-bf">function StructB (StructB this, float f) func = => GetA3;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>operator</code></h4>
              <p>运算符重载声明。</p>
              <pre><code class="language-bf">public static StructA operator+(StructA lhs, StructA rhs)
{
    return .();
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>extern</code></h4>
              <p>外部符号声明。</p>
              <pre><code class="language-bf">[LinkName(.CPP)]
public extern int32 MethodA0(int32 arg0) mut;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>concrete</code></h4>
              <p>接口方法返回具体类型。</p>
              <pre><code class="language-bf">interface IFaceC
{
    concrete IFaceA GetConcreteIA();
}
</code></pre>
            </div>
          </div>
        </div>
        <div class="keyword-group">
          <h3>访问级别与修饰符</h3>
          <div class="syntax-grid">
            <div class="syntax-card">
              <h4><code>public</code></h4>
              <p>公有可见性。</p>
              <pre><code class="language-bf">public int mA = 123;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>private</code></h4>
              <p>私有可见性。</p>
              <pre><code class="language-bf">private int mB;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>protected</code></h4>
              <p>受保护可见性。</p>
              <pre><code class="language-bf">protected int mC;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>internal</code></h4>
              <p>程序集内部可见。</p>
              <pre><code class="language-bf">internal int mD;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>static</code></h4>
              <p>静态成员/方法。</p>
              <pre><code class="language-bf">public static int sVal = 0;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>abstract</code></h4>
              <p>抽象类型/成员。</p>
              <pre><code class="language-bf">abstract class ClassD
{
    public int32 Val { get; set; }
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>virtual</code></h4>
              <p>虚方法。</p>
              <pre><code class="language-bf">public virtual int GetB(float f)
{
    return (int)f + 1000;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>override</code></h4>
              <p>重写虚方法。</p>
              <pre><code class="language-bf">public override int GetB(float f)
{
    return (int)f + 2000;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>sealed</code></h4>
              <p>禁止继承。</p>
              <pre><code class="language-bf">public sealed class Thread
{
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>const</code></h4>
              <p>编译期常量。</p>
              <pre><code class="language-bf">const int fac = Factorial(8);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>readonly</code></h4>
              <p>只读字段/引用。</p>
              <pre><code class="language-bf">private readonly Task m_task;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>volatile</code></h4>
              <p>易变字段。</p>
              <pre><code class="language-bf">public static volatile StreamWriter mOut ~ delete _;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>fixed</code></h4>
              <p>固定内存地址。</p>
              <pre><code class="language-bf">byte[] bytes = new byte[2];
fixed(byte* b = bytes)
    *((short*)b) = value;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>inline</code></h4>
              <p>内联提示特性。</p>
              <pre><code class="language-bf">[Inline]
public static int Add(int a, int b)
{
    return a + b;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>explicit</code></h4>
              <p>显式类型转换。</p>
              <pre><code class="language-bf">public static explicit operator T(Nullable<T> value)
{
    return value.Value;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>implicit</code></h4>
              <p>隐式类型转换。</p>
              <pre><code class="language-bf">public static implicit operator StructA(float f)
{
    return .() { mA = (.)f };
}
</code></pre>
            </div>
          </div>
        </div>

        <div class="keyword-group">
          <h3>控制流</h3>
          <div class="syntax-grid">
            <div class="syntax-card">
              <h4><code>if</code></h4>
              <p>条件分支。</p>
              <pre><code class="language-bf">if (num > 999)
    Test.FatalError();
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>else</code></h4>
              <p>条件分支的否定分支。</p>
              <pre><code class="language-bf">if (CheckFalse(scope ClassA()))
{
}
else
{
    Test.Assert(true);
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>switch</code></h4>
              <p>多分支匹配。</p>
              <pre><code class="language-bf">switch (val)
{
case 0:
    result = 1;
default:
    result = 3;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>case</code></h4>
              <p>匹配分支或模式。</p>
              <pre><code class="language-bf">case .B(let b):
    result = (.)b;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>default</code></h4>
              <p>默认分支。</p>
              <pre><code class="language-bf">default:
    result = 4;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>when</code></h4>
              <p>模式分支条件。</p>
              <pre><code class="language-bf">case .Circle(let x, let y, let r) when x == 10:
    return 12;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>for</code></h4>
              <p>for 与 foreach 语法。</p>
              <pre><code class="language-bf">for (int i in 1..<10)
    total += i;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>while</code></h4>
              <p>while 循环。</p>
              <pre><code class="language-bf">while (false)
{
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>do</code></h4>
              <p>do/while 循环。</p>
              <pre><code class="language-bf">do
{
}
while (false);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>repeat</code></h4>
              <p>repeat/while 循环。</p>
              <pre><code class="language-bf">repeat
{
    index = index * 10 + ch - '0';
}
while (ch >= '0' && ch <= '9');
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>break</code></h4>
              <p>终止循环或 switch。</p>
              <pre><code class="language-bf">break SWITCH2;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>continue</code></h4>
              <p>跳过当前迭代。</p>
              <pre><code class="language-bf">if (idx == 0)
    continue;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>fallthrough</code></h4>
              <p>switch 分支继续执行下一个分支。</p>
              <pre><code class="language-bf">case 3: c <<= 6; fallthrough;
case 2: c <<= 6; break;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>return</code></h4>
              <p>函数返回。</p>
              <pre><code class="language-bf">return a + b;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>yield</code></h4>
              <p>迭代器返回元素。</p>
              <pre><code class="language-bf">yield return trackedElement;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>try</code></h4>
              <p>异常捕获块。</p>
              <pre><code class="language-bf">try {
    ValidateTimeZoneInfo(...);
}
catch (ArgumentException e) { }
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>catch</code></h4>
              <p>捕获异常。</p>
              <pre><code class="language-bf">catch (InvalidTimeZoneException e)
{
    throw new SerializationException(..., e);
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>finally</code></h4>
              <p>异常结束后执行块（语法形式）。</p>
              <pre><code class="language-bf">try { }
finally { }
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>throw</code></h4>
              <p>抛出异常。</p>
              <pre><code class="language-bf">throw new SerializationException("Serialization_InvalidData");
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>goto</code></h4>
              <p>跳转到标签（语法形式）。</p>
              <pre><code class="language-bf">goto LABEL;
LABEL:
    result = 1;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>defer</code></h4>
              <p>作用域退出时执行。</p>
              <pre><code class="language-bf">defer::
{
    val += 100;
}
</code></pre>
            </div>
          </div>
        </div>
        <div class="keyword-group">
          <h3>类型、表达式与编译期</h3>
          <div class="syntax-grid">
            <div class="syntax-card">
              <h4><code>var</code></h4>
              <p>类型推断变量。</p>
              <pre><code class="language-bf">var str = scope String();
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>let</code></h4>
              <p>只读变量推断。</p>
              <pre><code class="language-bf">let (a, b, c) = (1, 2, 3);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>ref</code></h4>
              <p>引用语义。</p>
              <pre><code class="language-bf">ref StructA sa = ref arr[0];
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>in</code></h4>
              <p>只读引用参数。</p>
              <pre><code class="language-bf">public extern ref float MethodA3(in float val);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>out</code></h4>
              <p>输出参数/匹配绑定。</p>
              <pre><code class="language-bf">case .C(out a, out b):
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>mut</code></h4>
              <p>可变方法或参数。</p>
              <pre><code class="language-bf">public int GetA2(float f) mut
{
    return mA + (int)f;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>params</code></h4>
              <p>可变参数。</p>
              <pre><code class="language-bf">public static int Accumulate(params Span<int> args)
{
    return 0;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>where</code></h4>
              <p>泛型约束。</p>
              <pre><code class="language-bf">class ClassB<T> where T : IDisposable
{
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>is</code></h4>
              <p>类型/模式判断。</p>
              <pre><code class="language-bf">if (TRange is var)
    return;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>as</code></h4>
              <p>安全类型转换。</p>
              <pre><code class="language-bf">if (var list = data as List<T>)
{
    list.Add(item);
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>not</code></h4>
              <p>模式否定。</p>
              <pre><code class="language-bf">if (iResult not case .Ok(var result2))
{
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>null</code></h4>
              <p>空引用字面量。</p>
              <pre><code class="language-bf">String s = null;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>true / false</code></h4>
              <p>布尔字面量。</p>
              <pre><code class="language-bf">while (false)
{
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>nullable</code></h4>
              <p>可空类型形式。</p>
              <pre><code class="language-bf">public static nullable(T) operator?(Self val)
{
    return null;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>typeof</code></h4>
              <p>获取类型。</p>
              <pre><code class="language-bf">Type t = typeof(T);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>decltype</code></h4>
              <p>表达式类型。</p>
              <pre><code class="language-bf">decltype(i + 100) j = 123;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>nameof</code></h4>
              <p>符号名。</p>
              <pre><code class="language-bf">Test.Assert(nameof(System.Collections) == "Collections");
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>sizeof</code></h4>
              <p>类型大小。</p>
              <pre><code class="language-bf">Test.Assert(sizeof(UnionA) == 4);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>alignof</code></h4>
              <p>类型对齐。</p>
              <pre><code class="language-bf">Test.Assert(alignof(UnionD) == 4);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>strideof</code></h4>
              <p>跨度大小。</p>
              <pre><code class="language-bf">Test.Assert(strideof(StructC) == 8);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>offsetof</code></h4>
              <p>字段偏移。</p>
              <pre><code class="language-bf">int b = offsetof(String, mPtrOrBuffer);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>default</code></h4>
              <p>默认值。</p>
              <pre><code class="language-bf">StructA sa = default;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>comptype</code></h4>
              <p>编译期类型生成。</p>
              <pre><code class="language-bf">public typealias TA = comptype(GetVal(10, T));
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>alloctype</code></h4>
              <p>分配类型约束。</p>
              <pre><code class="language-bf">alloctype(T) val = new T();
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>rettype</code></h4>
              <p>委托返回类型推导。</p>
              <pre><code class="language-bf">public rettype(T) Invoke(params T p) mut
{
    var result = default(rettype(T));
    return result;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>append</code></h4>
              <p>追加内存/字段。</p>
              <pre><code class="language-bf">uint8* ptr = append uint8[3]*;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>box</code></h4>
              <p>装箱值类型。</p>
              <pre><code class="language-bf">var boxedVal = scope box valA;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>scope</code></h4>
              <p>作用域分配。</p>
              <pre><code class="language-bf">ClassA ca = scope ClassA();
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>mixin</code></h4>
              <p>编译期内联片段。</p>
              <pre><code class="language-bf">static mixin MixNums(int a, int b)
{
    (a << 8) | b
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>this</code></h4>
              <p>构造器与实例引用。</p>
              <pre><code class="language-bf">public this(int a, int b)
{
    mA = a;
    mB = b;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>base</code></h4>
              <p>基类成员访问。</p>
              <pre><code class="language-bf">public int BaseIndex
{
    get { return base[2]; }
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>new</code></h4>
              <p>创建对象或值。</p>
              <pre><code class="language-bf">ClassA ca = new ClassA();
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>delete</code></h4>
              <p>显式释放对象。</p>
              <pre><code class="language-bf">delete ca;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>checked</code></h4>
              <p>检查溢出的语法/特性（语法形式）。</p>
              <pre><code class="language-bf">checked
{
    int x = a + b;
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>unchecked</code></h4>
              <p>不检查溢出的表达式。</p>
              <pre><code class="language-bf">public const uint32 UnsignedInfinite = unchecked((uint32)-1);
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>asm</code></h4>
              <p>内联汇编（语法形式）。</p>
              <pre><code class="language-bf">asm
{
    mov eax, ebx
}
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>unsigned</code></h4>
              <p>无符号修饰（语法形式）。</p>
              <pre><code class="language-bf">unsigned int value = 1;
</code></pre>
            </div>
            <div class="syntax-card">
              <h4><code>isconst</code></h4>
              <p>常量表达式检查（语法形式）。</p>
              <pre><code class="language-bf">if (val is const)
{
}
</code></pre>
            </div>
          </div>
        </div>
      </section>

      <section id="operators" style="--delay: 0.11s;">
        <h2>运算符与符号全量 <span class="tag">operators</span></h2>
        <p>包含算术、比较、逻辑、位运算、空值与范围语法等。</p>
        <table class="syntax-table">
          <thead>
            <tr>
              <th>符号</th>
              <th>含义</th>
              <th>示例</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>=</code></td><td>赋值</td><td><code>a = 1;</code></td></tr>
            <tr><td><code>+=</code></td><td>加法赋值</td><td><code>a += 10;</code></td></tr>
            <tr><td><code>-=</code></td><td>减法赋值</td><td><code>a -= 1;</code></td></tr>
            <tr><td><code>*=</code></td><td>乘法赋值</td><td><code>a *= 2;</code></td></tr>
            <tr><td><code>/=</code></td><td>除法赋值</td><td><code>a /= 3;</code></td></tr>
            <tr><td><code>%=</code></td><td>取模赋值</td><td><code>a %= 5;</code></td></tr>
            <tr><td><code>&amp;+=</code></td><td>溢出加法赋值</td><td><code>a &amp;+= 1;</code></td></tr>
            <tr><td><code>&amp;-=</code></td><td>溢出减法赋值</td><td><code>a &amp;-= 1;</code></td></tr>
            <tr><td><code>&amp;*=</code></td><td>溢出乘法赋值</td><td><code>a &amp;*= 2;</code></td></tr>
            <tr><td><code>==</code></td><td>相等</td><td><code>a == b</code></td></tr>
            <tr><td><code>!=</code></td><td>不等</td><td><code>a != b</code></td></tr>
            <tr><td><code>===</code></td><td>严格相等</td><td><code>strA === strB</code></td></tr>
            <tr><td><code>!==</code></td><td>严格不等</td><td><code>strA !== strB</code></td></tr>
            <tr><td><code>&lt;</code></td><td>小于</td><td><code>a &lt; b</code></td></tr>
            <tr><td><code>&gt;</code></td><td>大于</td><td><code>a &gt; b</code></td></tr>
            <tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>a &lt;= b</code></td></tr>
            <tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>a &gt;= b</code></td></tr>
            <tr><td><code>&lt;=&gt;</code></td><td>三向比较</td><td><code>1 &lt;=&gt; 2 &lt; 0</code></td></tr>
            <tr><td><code>+</code></td><td>加法</td><td><code>a + b</code></td></tr>
            <tr><td><code>-</code></td><td>减法/取负</td><td><code>-num</code></td></tr>
            <tr><td><code>*</code></td><td>乘法/指针解引用</td><td><code>*ptr = 1;</code></td></tr>
            <tr><td><code>/</code></td><td>除法</td><td><code>a / b</code></td></tr>
            <tr><td><code>%</code></td><td>取模</td><td><code>a % 2</code></td></tr>
            <tr><td><code>++</code></td><td>自增</td><td><code>++sAutoProp;</code></td></tr>
            <tr><td><code>--</code></td><td>自减</td><td><code>--i;</code></td></tr>
            <tr><td><code>&amp;</code></td><td>位与/取地址</td><td><code>ptr = &amp;value;</code></td></tr>
            <tr><td><code>|</code></td><td>位或</td><td><code>a | b</code></td></tr>
            <tr><td><code>^</code></td><td>位异或/从尾索引</td><td><code>arr[^1]</code></td></tr>
            <tr><td><code>~</code></td><td>位取反</td><td><code>~mask</code></td></tr>
            <tr><td><code>&amp;=</code></td><td>位与赋值</td><td><code>flags &amp;= mask;</code></td></tr>
            <tr><td><code>|=</code></td><td>位或赋值</td><td><code>flags |= mask;</code></td></tr>
            <tr><td><code>^=</code></td><td>位异或赋值</td><td><code>flags ^= mask;</code></td></tr>
            <tr><td><code>&amp;+</code></td><td>溢出加法</td><td><code>a &amp;+ b</code></td></tr>
            <tr><td><code>&amp;-</code></td><td>溢出减法</td><td><code>a &amp;- b</code></td></tr>
            <tr><td><code>&amp;*</code></td><td>溢出乘法</td><td><code>a &amp;* b</code></td></tr>
            <tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>val &lt;&lt; 8</code></td></tr>
            <tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>val &gt;&gt; 2</code></td></tr>
            <tr><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td><code>val &lt;&lt;= 1</code></td></tr>
            <tr><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td><code>val &gt;&gt;= 1</code></td></tr>
            <tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td><code>a &amp;&amp; b</code></td></tr>
            <tr><td><code>||</code></td><td>逻辑或</td><td><code>a || b</code></td></tr>
            <tr><td><code>!</code></td><td>逻辑非</td><td><code>!flag</code></td></tr>
            <tr><td><code>??</code></td><td>空合并</td><td><code>i = intn ?? 200;</code></td></tr>
            <tr><td><code>??=</code></td><td>空合并赋值</td><td><code>iNull ??= iNull2;</code></td></tr>
            <tr><td><code>?.</code></td><td>空条件访问</td><td><code>ca?.mCondB?.mInt</code></td></tr>
            <tr><td><code>?[]</code></td><td>空条件索引</td><td><code>arr?.[0]</code></td></tr>
            <tr><td><code>?:</code></td><td>条件表达式</td><td><code>n &lt;= 1 ? 1 : n * f(n-1)</code></td></tr>
            <tr><td><code>..</code></td><td>范围/级联捕获</td><td><code>MethodA(.. 12, .. 2.3f)</code></td></tr>
            <tr><td><code>...</code></td><td>闭区间/变参标记</td><td><code>for (int i in 1...10)</code></td></tr>
            <tr><td><code>..&lt;</code></td><td>半开区间</td><td><code>for (int i in 1..<10)</code></td></tr>
            <tr><td><code>.</code></td><td>成员访问</td><td><code>obj.Field</code></td></tr>
            <tr><td><code>::</code></td><td>作用域限定</td><td><code>scope:: () =&gt; { }</code></td></tr>
            <tr><td><code>-&gt;</code></td><td>指针/自定义箭头</td><td><code>result-&gt;ValueRef</code></td></tr>
            <tr><td><code>=&gt;</code></td><td>Lambda/委托</td><td><code>Action act = () =&gt; { };</code></td></tr>
            <tr><td><code>@</code></td><td>转义标识符</td><td><code>this ref StructA @this</code></td></tr>
            <tr><td><code>;</code></td><td>语句结束符</td><td><code>int a = 1;</code></td></tr>
            <tr><td><code>,</code></td><td>分隔符</td><td><code>(a, b, c)</code></td></tr>
            <tr><td><code>:</code></td><td>标签/属性语法</td><td><code>case .A:</code></td></tr>
            <tr><td><code>()</code></td><td>调用/分组</td><td><code>Func(a, b)</code></td></tr>
            <tr><td><code>[]</code></td><td>数组/索引/特性</td><td><code>[Inline] int this[int i]</code></td></tr>
            <tr><td><code>{}</code></td><td>代码块/初始化器</td><td><code>StructA sa = .() { mA = 1 };</code></td></tr>
          </tbody>
        </table>
      </section>
      <section id="attributes" style="--delay: 0.14s;">
        <h2>内建特性（Attributes） <span class="tag">attributes</span></h2>
        <p>特性是语法级元数据入口，常用于编译期/反射/ABI/内存布局。</p>
        <div class="syntax-grid">
          <div class="syntax-card">
            <h4><code>[AttributeUsage]</code></h4>
            <p>声明特性可用范围。</p>
            <pre><code class="language-bf">[AttributeUsage(.Method)]
struct LogAttribute : Attribute { }
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Reflect]</code></h4>
            <p>启用反射数据生成。</p>
            <pre><code class="language-bf">[Reflect]
class ClassA { }
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[AlwaysInclude]</code></h4>
            <p>强制包含成员。</p>
            <pre><code class="language-bf">[AlwaysInclude]
static StructA StaticMethodB(ref int32 a, ref String b)
{
    return default;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Inline]</code></h4>
            <p>内联提示。</p>
            <pre><code class="language-bf">[Inline]
public static int TimesTwo(int a) { return a * 2; }
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Comptime]</code></h4>
            <p>编译期执行。</p>
            <pre><code class="language-bf">[Comptime]
public static int32 ConstSum(params int32[] vals)
{
    return 0;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[CRepr]</code></h4>
            <p>C ABI 布局。</p>
            <pre><code class="language-bf">[CRepr]
public struct StructA
{
    public int32 mA;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Union]</code></h4>
            <p>联合体布局。</p>
            <pre><code class="language-bf">[Union]
struct UnionB
{
    public int32 mInt32;
    public float mFloat;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Bitfield]</code></h4>
            <p>位域成员。</p>
            <pre><code class="language-bf">[Bitfield<uint8>(.Public, "A")]
[Bitfield<uint8>(.Public, .Bits(3), "B")]
public int32 mVal;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[AllowAppend]</code></h4>
            <p>允许 append 内存。</p>
            <pre><code class="language-bf">[AllowAppend]
public this()
{
    uint8* ptr = append uint8[3]*;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[AllowDuplicates]</code></h4>
            <p>枚举允许重复值。</p>
            <pre><code class="language-bf">[AllowDuplicates]
public enum EnumJ : uint32
{
    SDL_BUTTON_LEFT = 1,
    SDL_BUTTON_LMASK = (1u << ((SDL_BUTTON_LEFT.Underlying) - 1)),
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[Commutable]</code></h4>
            <p>交换律运算符。</p>
            <pre><code class="language-bf">[Commutable]
public static bool operator<(StructA lhs, StructB rhs)
{
    return lhs.mA < rhs.mB;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[SkipCall]</code></h4>
            <p>跳过调用（常用于特殊属性）。</p>
            <pre><code class="language-bf">[SkipCall]
public int D => 123;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>[CLink] / [Import]</code></h4>
            <p>外部库链接。</p>
            <pre><code class="language-bf">[CLink, Import("msvcrt.dll")]
public static extern int32 sprintf(char8* dest, char8* fmt, ...);
</code></pre>
          </div>
        </div>
      </section>

      <section id="features" style="--delay: 0.17s;">
        <h2>结构化语法特性 <span class="tag">features</span></h2>
        <p>关键结构与高频语法特性示例。</p>
        <div class="syntax-grid">
          <div class="syntax-card">
            <h4><code>模式匹配</code></h4>
            <p><code>case</code> + 结构化绑定。</p>
            <pre><code class="language-bf">switch (res)
{
case .Ok(let a):
    return 0;
case .Err(let b):
    return 1;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>元组与解构</code></h4>
            <p>元组字段与解构赋值。</p>
            <pre><code class="language-bf">let (a, b, c) = (1, 2, 3);
(int32, float) tVal = (1, 2.0f);
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>范围与切片</code></h4>
            <p><code>Range</code> 与切片语法。</p>
            <pre><code class="language-bf">for (int i in 1...10)
    total += i;

var slice = iList[...^2];
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>空值传播</code></h4>
            <p><code>?.</code> 与 <code>??</code>。</p>
            <pre><code class="language-bf">int? iNull = null;
int i = iNull ?? 200;
var len = ca?.mCondB?.mStr?.Length;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>属性与索引器</code></h4>
            <p><code>get/set</code> 与 <code>this[...]</code>。</p>
            <pre><code class="language-bf">public int this[int index]
{
    get { return 123; }
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>扩展方法</code></h4>
            <p><code>this</code> 参数扩展。</p>
            <pre><code class="language-bf">public static int Remove(this String str, float val, float val2)
{
    return 123;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>using 成员</code></h4>
            <p>成员转发/提升。</p>
            <pre><code class="language-bf">using public ClassB B => sB;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>委托与捕获</code></h4>
            <p>闭包与捕获。</p>
            <pre><code class="language-bf">Action act = scope [&] () =>
{
    a += 100;
};
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>编译期生成</code></h4>
            <p>编译期生成类型体。</p>
            <pre><code class="language-bf">[Comptime]
public void ApplyToType(Type type)
{
    Compiler.EmitTypeBody(type, "public int32 mB = 234;");
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>互操作与 LinkName</code></h4>
            <p>跨语言调用。</p>
            <pre><code class="language-bf">[LinkName(.CPP)]
public extern StructA MethodA1(StructA sa, int32 arg0) mut;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>append 内存</code></h4>
            <p>对象末尾追加内存。</p>
            <pre><code class="language-bf">[AllowAppend]
public this()
{
    uint32* val = append uint32[2]*;
}
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>Boxing / Variant</code></h4>
            <p>装箱与变体。</p>
            <pre><code class="language-bf">Variant v = .Create(valA);
var boxed = v.GetBoxed().Value;
</code></pre>
          </div>
          <div class="syntax-card">
            <h4><code>联合体与位域</code></h4>
            <p>低层布局控制。</p>
            <pre><code class="language-bf">[Union]
struct UnionD : UnionC
{
    public int16 mInt16;
}
</code></pre>
          </div>
        </div>
      </section>

      <section id="note" style="--delay: 0.2s;">
        <h2>说明与参考 <span class="tag">refs</span></h2>
        <div class="note">
          示例主要来自：<code>IDEHelper/Tests/src/*.bf</code>、<code>IDE/Tests/Test1/src/*.bf</code>、<code>BeefLibs/corlib/src/*</code>、<code>IDE/mintest/minlib/src/*</code>。个别语法（如 <code>asm</code>、<code>checked</code>、<code>isconst</code>、<code>unsigned</code>）在仓库中缺少直接样例，已按语言语法形式补充示例。
        </div>
      </section>
    </div>
  </main>

  <footer>
    <div>源码参考：<code>IDEHelper/Tests/src</code>、<code>IDE/Tests/Test1/src</code>、<code>BeefLibs/corlib/src</code>、<code>IDE/mintest/minlib/src</code>。</div>
  </footer>
</body>
</html>
